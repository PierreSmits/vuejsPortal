BUG/TASK :
le link dans ExampleFeatureExternalMenu pointe sur une url du composant example, pas exampleapi. J'ai donc mis url-mode à inter-app. Il faut donc prendre en compte cette info pour générer correction l'url.

TASK (Doc):
Supprimer tous les ajouts liés à event-type="redirect" car il n'y a pas use-case pertinemt pour l'instant

TASK :
Le wait-spinner n'est activé que par le setArea alors que les post peuvent être long.
Pour l'instant, il faut attendre le résultat des post donc le wait-spinner devrait se déclancher dès le post.

TASK :
faire fonctionner l'autocomplétion
l'idée est de faire sans regarder le javascript ofbiz de manière à être le plus VueJs "classique".
Pour l'autocomplétion, il faut utiliser lookupFieldFormName en tant que target (comme target d'un on-update) avec comme parametres :
* ajaxLookup=Y
* searchValueFieldName=le nom du champ
* term=le contenu tapé

Actuellement ce qui est renvoyé est mis en form par AjaxAutocompleteOptions.ftl, il est dans example donc modifiable
OH-remarque : Il est possible de le remplacer par une form xml classique. Est ce nécessaire ?

Info :
searchValueFieldName est utilisé si term est vide, il cherche alors si la valeur est présente dans parameters
    def searchValueFieldName = parameters.term
    def fieldValue = null
    if (searchValueFieldName) {
        fieldValue = searchValueFieldName
    } else if (parameters.searchValueFieldName) { // This is to find the description of a lookup value on initialization.
       fieldValue = parameters.get(parameters.searchValueFieldName)
       context.description = "true"
    }

Pour faire des tests du fonctionnement actuel
https://localhost:8443/example/control/EditExampleFeatureAppls?exampleId=EX02

TASK :
gérer les champs date renderDateTimeField, il y en a deux dans le edit de la portlet ExampleFeatureAppl

TASK :
ouverture et affichag du screen du lookup dans 1 pop-up
Est utile aussi pour des boutons actions (de type link) pour pouvoir faire une (ou plusieurs) action/s dans une fenêtre modal (cf ExampleFeature creation/management à partir de la page ExampleMgmt).

TASK :
syntaxe et fonctionnement du hyperlink de retour d'un lookup.
La difficulté c'est que, au niveau du formulaire, le lookup list, ne connait pas le formulaire appelant.
Donc je pensais passer par un store dédié lookup mais ça voudrait dire que le champ du formulaire se mets à jours selon le store entity ou le store lookup !

TASK :
pouvoir définir 2 watcher pour une portlet dans une portalPage, le nom des multiple watcher sont séparé par une virgule (ou espace ou ...)
Le cas d'usage est la page recap avec la portlet ExampleStatus, elle doit se mettre à jour quand l'id change via la portlet selectExample et aussi quand editExample à lieu (car le status  peut être modifié).
le commit est fait comme si cela fonctionnait

TASK :
post versus delete pour l'uri deleteExampleFeatureAppl
faut'il le différentier ? dans le xml et dans le vueJs

TASK :
Au niveau du lookup autocomplétion, il faudrait le faire via une URI renvoyant du JSON.
Pour le faire:
  1) transformer le groovy FindAutocompleteOptions.groovy en event et en java (prendre pour exemple HumanResEvents.java#getChildHRCategoryTree)
    <request-map uri="getHRChild">
        <security auth="false" https="true"/>
        <event type="java" path="org.apache.ofbiz.humanres.HumanResEvents" invoke="getChildHRCategoryTree"/>
        <response name="success" type="request" value="json"/>
        <response name="error" type="request" value="json"/>
    </request-map>
   2) faire un groovy appelable en event qui mettrais les paramétres du lookup(entityName, searchFields, returnField, displayFields) dans la request
      en se basant sur PrepareCreateShipMeth.groovy en tant qu'exemple
          <!-- entries needed for lookup ajax auto completer -->
          <!-- required: entity to search in -->
          <set field="entityName" value="Example"/>

          <!-- required: fields to search a match -->
          <set field="searchFields" value="[exampleId, exampleName, description]"/>

          <!-- optional: field to return after user selection, default is first element of searchFields -->
          <!-- return field might be hidden based on widget.autocompleter.displayReturnField property in widget.properties -->
          <!--set field="returnField" value="exampleFeatureId"/-->

          <!-- optional: fields to display, default are searchFields -->
          <set field="displayFields" value="[exampleName]"/>
   3) créer la request autocompleteExampleId, quelquechose du genre:
    <request-map uri="autocompleteExample">
        <security auth="true" https="true"/>
        <event type="groovy" path="component://exemple/groovyScripts/example/autocompleteExampleId.groovy"/>
        <response name="success" type="request" value="returnAutocompletJson"/>
    </request-map>
    <request-map uri="returnAutocompletJson">
        <security auth="true" https="true"/>
        <event type="java" path="org.apache.ofbiz.common.CommonEventss" invoke="findAutocompleteOptions"/>
        <response name="success" type="request" value="json"/>
        <response name="error" type="request" value="json"/>
    </request-map>
    4) OPTION Tant qu'à être complet inclure dans le java la préparation complete des données donc faire ce qui était fait dans le ftl
       AjaxAutocompleteOptions.ftl
   


