BUG/TASK :
le link dans ExampleFeatureExternalMenu pointe sur une url du composant example, pas exampleapi. J'ai donc mis url-mode à inter-app. Il faut donc prendre en compte cette info pour générer correction l'url.

TASK (Doc):
Supprimer tous les ajouts liés à event-type="redirect" car il n'y a pas use-case pertinemt pour l'instant

TASK (Doc):
Supprimer tous les ajouts liés à l'usage de ftl pour la gestion des lookup.

TASK :
Le wait-spinner n'est activé que par le setArea alors que les post peuvent être long.
Pour l'instant, il faut attendre le résultat des post donc le wait-spinner devrait se déclancher dès le post.

TASK :
gérer les champs date renderDateTimeField, il y en a deux dans le edit de la portlet ExampleFeatureAppl

TASK :
ouverture et affichag du screen du lookup dans 1 pop-up
Est utile aussi pour des boutons actions (de type link) pour pouvoir faire une (ou plusieurs) action/s dans une fenêtre modal (cf ExampleFeature creation/management à partir de la page ExampleMgmt).

TASK :
syntaxe et fonctionnement du hyperlink de retour d'un lookup.
La difficulté c'est que, au niveau du formulaire, le lookup list, ne connait pas le formulaire appelant.
Donc je pensais passer par un store dédié lookup mais ça voudrait dire que le champ du formulaire se mets à jours selon le store entity ou le store lookup !

TASK :
pouvoir définir 2 watcher pour une portlet dans une portalPage, le nom des multiple watcher sont séparé par une virgule (ou espace ou ...)
Le cas d'usage est la page recap avec la portlet ExampleStatus, elle doit se mettre à jour quand l'id change via la portlet selectExample et aussi quand editExample à lieu (car le status  peut être modifié).
le commit est fait comme si cela fonctionnait

TASK :
introduire une balise xml dans les screens à l'intérieur de <plateform-specific> qui serait <vuejs avec un fonctionnement similaire à ce qui ce fait pour html
   syntaxe actuel (exemple): <platform-specific><html><html-template location="component://common-theme/template/includes/SetDependentDropdownValuesJs.ftl"/></html></platform-specific>
   3 étapes :
     1) Re-comprendre la logic des renderer et plus particulièrement le FrontJs renderer. Partir du FrontJsScreenViewHandler.java et suivre les appels vers les class Model (lecture du xml)
        puis l'enchainement des appelles aux renderers et enfin la gestion des output ( screen et entity)
     2) ajout XSD, model, et donc renderer, en fonction des besoins définitions des attribues dans le XML
        et bien sur implémentation vueJs
     3) petite généralisation, soit chargement à la demande, soit multiple paramètres liés à ce composant spécific, via paramètre screen (dans le xml) ou via paramètre de portlet, (dans le context).
        généralisation possible aussi dans les form xml pour remplacer de l'appel à javascript, (ex de use case: le contenu d'un drop-down dépend d'un autre drop-down)
  cas d'usage :
    1) simple les ftl de la gestion des coordonnées, utilisable pour un acteur, une zone de stockage, une commande
       idem pour la gestion des moyens de paiement
    2) Représentation en Arbre, les tree en XML, exemple PartyTrees.xml <tree name="OrgTree" 


TASK :
post versus delete pour l'uri deleteExampleFeatureAppl
faut'il le différentier ? dans le xml et dans le vueJs

TASK :
Pour être plus propre, au niveau du lookup autocomplétion, il faudrait le faire via une URI renvoyant du JSON (et non via un screen).
Pour le faire:
  1) transformer le groovy FindAutocompleteOptions.groovy en event et en java (prendre pour exemple HumanResEvents.java#getChildHRCategoryTree)
    <request-map uri="getHRChild">
        <security auth="false" https="true"/>
        <event type="java" path="org.apache.ofbiz.humanres.HumanResEvents" invoke="getChildHRCategoryTree"/>
        <response name="success" type="request" value="json"/>
        <response name="error" type="request" value="json"/>
    </request-map>
   2) faire un groovy appelable en event qui mettrais les paramétres du lookup(entityName, searchFields, returnField, displayFields) dans la request
      en se basant sur PrepareCreateShipMeth.groovy en tant qu'exemple
          <!-- entries needed for lookup ajax auto completer -->
          <!-- required: entity to search in -->
          <set field="entityName" value="Example"/>

          <!-- required: fields to search a match -->
          <set field="searchFields" value="[exampleId, exampleName, description]"/>

          <!-- optional: field to return after user selection, default is first element of searchFields -->
          <!-- return field might be hidden based on widget.autocompleter.displayReturnField property in widget.properties -->
          <!--set field="returnField" value="exampleFeatureId"/-->

          <!-- optional: fields to display, default are searchFields -->
          <set field="displayFields" value="[exampleName]"/>
   3) créer la request autocompleteExampleId, quelquechose du genre:
    <request-map uri="autocompleteExample">
        <security auth="true" https="true"/>
        <event type="groovy" path="component://exemple/groovyScripts/example/autocompleteExampleId.groovy"/>
        <response name="success" type="request" value="returnAutocompletJson"/>
    </request-map>
    <request-map uri="returnAutocompletJson">
        <security auth="true" https="true"/>
        <event type="java" path="org.apache.ofbiz.common.CommonEventss" invoke="findAutocompleteOptions"/>
        <response name="success" type="request" value="json"/>
        <response name="error" type="request" value="json"/>
    </request-map>
    4) OPTION Tant qu'à être complet inclure dans le java la préparation complete des données donc faire ce qui était fait dans le ftl
       AjaxAutocompleteOptions.ftl
    5) supprimer tout les fichiers inutile dans example lié au Hack, par exemple les decorator

TASK :
Activer l'attribue <description-field-name> de la balise lookup, cet attribue sert à mettre à jours un champ "description" présent dans la form avec la description.
Pour jouer / tester, j'ai utilisé  https://localhost:8443/catalog/control/EditProductAssoc?productId=GZ-1000
et donc le fichier LookupScreens.xml dans catalog screen name="LookupProduct" et ajout de     <set field="displayFields" value="[productTypeId, internalName]"/>
puis dans ProductForms.xml au niveau de EditProductAssoc lgn 1164 il est possible de tester les différents attribues du tag lookup, par exemple l'ajout de 
show-description="true" description-field-name="reason"



