package com.otoit.spapi;

import com.auth0.jwt.JWTExpiredException;
import com.auth0.jwt.JWTSigner;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.JWTVerifyException;

import javolution.util.FastList;

import org.apache.commons.io.FileUtils;
import org.ofbiz.base.util.Base64;
import org.ofbiz.base.util.Debug;
import org.ofbiz.base.util.UtilDateTime;
import org.ofbiz.base.util.UtilGenerics;
import org.ofbiz.base.util.UtilMisc;
import org.ofbiz.base.util.UtilProperties;
import org.ofbiz.base.util.UtilValidate;
import org.ofbiz.base.util.string.FlexibleStringExpander;
import org.ofbiz.entity.Delegator;
import org.ofbiz.entity.GenericEntityException;
import org.ofbiz.entity.GenericValue;
import org.ofbiz.entity.condition.EntityComparisonOperator;
import org.ofbiz.entity.condition.EntityCondition;
import org.ofbiz.entity.condition.EntityFunction;
import org.ofbiz.entity.condition.EntityJoinOperator;
import org.ofbiz.entity.condition.EntityOperator;
import org.ofbiz.entity.model.DynamicViewEntity;
import org.ofbiz.entity.model.ModelKeyMap;
import org.ofbiz.entity.util.EntityFindOptions;
import org.ofbiz.entity.util.EntityListIterator;
import org.ofbiz.entity.util.EntityUtil;
import org.ofbiz.entity.util.EntityUtilProperties;
import org.ofbiz.product.product.ProductSearch;
import org.ofbiz.security.Security;
import org.ofbiz.service.DispatchContext;
import org.ofbiz.service.GenericServiceException;
import org.ofbiz.service.ServiceUtil;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SignatureException;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.TimeZone;

public class SPAPISServices {
	public static final String module = SPAPISServices.class.getName();
	public static final String resource = "OtoitUiLabels";
	private static final String  secretKey = UtilProperties.getPropertyValue("spapi", "authentication.token.key");
	private static final int expiry = UtilProperties.getPropertyAsInteger("spapi", "authentication.token.expiry", 600);
	public static final DateFormat dateIsoFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mmZ");

	private static final Map<String, String> uomTranslate = UtilMisc.toMap(
		"VLIQ_L", "BasicUnitLiter",
		"VLIQ_cl", "BasicUnitCentiliter",
		"VLIQ_ml", "BasicUnitMilliliter",
		"OTH_pi", "BasicUnitPiece",
		"WT_kg", "BasicUnitKilogram",
		"WT_g", "BasicUnitGram",
		"WT_mg", "BasicUnitMilligram"
	);

    protected static String generateUserToken(String userName) {

        JWTSigner signer = new JWTSigner(secretKey);

        JWTSigner.Options options = new JWTSigner.Options().setExpirySeconds(expiry);

        Map<String, Object> claims = UtilMisc.toMap("username", userName);

        String token = signer.sign(claims, options);

        return token;
    }
    
    public static String checkToken(HttpServletRequest request, HttpServletResponse response) {
        String token = request.getParameter("token");
        if (UtilValidate.isNotEmpty(token)) {
            JWTVerifier verifier = new JWTVerifier(secretKey);

            Map<String, Object> claims = ServiceUtil.returnSuccess();

            try {
                claims.putAll(verifier.verify(token));
                String username = (String) claims.get("username");
                request.setAttribute("username", username);
                request.setAttribute("anonymous", (Boolean) claims.get("anonymous"));
                return "success";
            } catch (IOException e) {
                 Debug.logError("Authentication error : " + e.getMessage(), module);
            } catch (InvalidKeyException e) {
                Debug.logError("Authentication error : " + e.getMessage(), module);
            } catch (NoSuchAlgorithmException e) {
                Debug.logError("Authentication error : " + e.getMessage(), module);
            } catch (JWTVerifyException e) {
                if (e instanceof JWTExpiredException) {
                    Debug.logError("tokenError: expired "  + e.getMessage(), module);
                } else {
                    Debug.logError("tokenError : invalidToken " + e.getMessage(), module);
                }
            } catch (SignatureException e) {
                Debug.logError("tokenError: signatureRejected " + e.getMessage(), module);
            }
            return "error";
        }
        return "success";
    }
    
    public static Map<String, Object> apisLogin(DispatchContext dctx, Map<String, ? extends Object> context) {
        Map<String, Object> results = new HashMap<String, Object>();
        try {
            GenericValue userLogin = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));
            if (UtilValidate.isNotEmpty(userLogin) && UtilValidate.isEmpty(userLogin.getString("lastLocale"))) {
                userLogin.set("lastLocale", "fr");
            }
            
            Map<String, Object> localCtx = dctx.makeValidContext("userLogin", "IN", context);
            localCtx.remove("userLogin");
            localCtx.put("isServiceAuth", Boolean.TRUE);
            localCtx.put("login.username", context.get("username"));
            localCtx.put("login.password", context.get("password"));
            results = dctx.getDispatcher().runSync("userLogin", localCtx);
            if (ServiceUtil.isError(results)) {
                return ServiceUtil.returnError(ServiceUtil.getErrorMessage(results));
            } else {
                Security security =  dctx.getSecurity();
                if(security.hasPermission("SH-SUPPL-PORT_ADMIN", userLogin)) {
                    results.put("token", generateUserToken((String)context.get("username")));
                    results.putAll(ServiceUtil.returnSuccess("indentifiant / mot de passe acceptés"));
                    return results;
                }
                else {
                    return ServiceUtil.returnError("Vous n'êtes pas autorisé à vous connecter à cette application !");
                }
            }
        }
        catch(GenericServiceException gse) {
            return ServiceUtil.returnError("erreur d'authetification : " + gse.getMessage());
        }
        catch(GenericEntityException gee) {
            return ServiceUtil.returnError("erreur d'authetification : " + gee.getMessage());
        }
    }
    
    public static Map<String, Object> checkAuthToken(DispatchContext dctx, Map<String, ? extends Object> context) {

        JWTVerifier verifier = new JWTVerifier(secretKey);

        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {
            results.putAll(verifier.verify((String) context.get("token")));
            if (results.containsKey("exp")) {
                results.remove("exp");
            }
            GenericValue userLogin = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", results.get("username"));
            if (UtilValidate.isNotEmpty(userLogin)) {
                results.remove("exp");
            }
        } catch (IOException e) {
            results = ServiceUtil.returnError("Authentication error : " + e.getMessage());
            results.put("tokenError", "tokenCorrupted");
        } catch (InvalidKeyException e) {
            results = ServiceUtil.returnError("Authentication error : " + e.getMessage());
            results.put("tokenError", "invalidKey");
        } catch (NoSuchAlgorithmException e) {
            results = ServiceUtil.returnError("Authentication error : " + e.getMessage());
            results.put("tokenError", "tokenCorrupted");
        } catch (JWTVerifyException e) {
            results = ServiceUtil.returnError("Authentication error : " + e.getMessage());
            if (e instanceof JWTExpiredException) {
                results.put("tokenError", "expired");
            } else {
                results.put("tokenError", "invalidToken");
            }
        } catch (SignatureException e) {
            results = ServiceUtil.returnError("Authentication error : " + e.getMessage());
            results.put("tokenError", "signatureRejected");
        } catch(Exception e) {
            results = ServiceUtil.returnError("Authentication error : " + e.getMessage());
            results.put("tokenError", "signatureRejected");
        }
        return results;
    }
    public static Map<String, Object> getOrderToPrepare(DispatchContext dctx, Map<String, ? extends Object> context) {

        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {
            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));

            List<GenericValue> oisgToPrepares = dctx.getDelegator().findList(
                    "OISGToPrepareViewRoof",
                    EntityCondition.makeCondition(
                            UtilMisc.toList(
                                    EntityCondition.makeCondition("supplierPartyId", EntityComparisonOperator.EQUALS, login.getString("partyId")),
                                    EntityCondition.makeCondition("statusId", EntityComparisonOperator.IN, UtilMisc.toList("ORDER_SENT", "ORDER_PROCESS_PREP", "ORDER_PREPARED")),
                                    EntityCondition.makeCondition("shipmentMethodTypeId", EntityComparisonOperator.EQUALS, "DROP_SHIP_ROOF")
                            ),
                            EntityJoinOperator.AND),
                    null,
                    UtilMisc.toList("orderDate"),
                    new EntityFindOptions(true, EntityFindOptions.TYPE_SCROLL_INSENSITIVE, EntityFindOptions.CONCUR_READ_ONLY, -1, 0, true),
                    false);

            List<Map<String, Object>> orders = new ArrayList<Map<String, Object>>();

            for (GenericValue oisgToPrepare : oisgToPrepares) {

                List<GenericValue> orderCustomers = dctx.getDelegator().findByAnd(
                        "OrderItemAssoc",
                        UtilMisc.toMap(
                                "toOrderId", oisgToPrepare.getString("orderId"),
                                "toShipGroupSeqId", oisgToPrepare.getString("shipGroupSeqId"),
                                "orderItemAssocTypeId", "DROP_SHIPMENT"
                        ),
                        UtilMisc.toList("orderId"),
                        false
                );

                if (orderCustomers.isEmpty()) {
                    return ServiceUtil.returnError("No customer order found for supplier order");
                }

                GenericValue orderCustomer = dctx.getDelegator().findOne(
                        "OrderHeader",
                        UtilMisc.toMap("orderId", orderCustomers.get(0).getString("orderId")),
                        false);

                Map<String, Object> order = UtilMisc.toMap(
                        "id", oisgToPrepare.getString("orderId"),
                        "shipGroup", oisgToPrepare.getString("shipGroupSeqId"),
                        "status", oisgToPrepare.getString("statusId"),
                        "date", orderCustomer.getString("orderDate"),
                        "estimatedDeliveryDate", oisgToPrepare.getString("estimatedDeliveryDate")
                );

                // roof
                GenericValue facility = EntityUtil.getFirst(
                        dctx.getDelegator().findList(
                                "FacilityAndContactMech",
                                EntityCondition.makeCondition(
                                        UtilMisc.toList(
                                                EntityCondition.makeCondition("facilityId", EntityComparisonOperator.EQUALS, oisgToPrepare.getString("facilityId")),
                                                EntityCondition.makeCondition("facilityTypeId", EntityComparisonOperator.EQUALS, "PRIMARY_ROOF"),
                                                EntityCondition.makeCondition("contactMechTypeId", EntityComparisonOperator.EQUALS, "POSTAL_ADDRESS")
                                        ),
                                        EntityJoinOperator.AND),
                                UtilMisc.toSet("facilityId","facilityName", "contactMechId"),
                                UtilMisc.toList("facilityId"),
                                new EntityFindOptions(true, EntityFindOptions.TYPE_SCROLL_INSENSITIVE, EntityFindOptions.CONCUR_READ_ONLY, -1, 0, true),
                                false));
                if (UtilValidate.isNotEmpty(facility)) {
                    order.put("roof", UtilMisc.toMap(
                            "id", facility.getString("facilityId"),
                            "name", facility.getString("facilityName")
                    ));
                }

                // customer
                GenericValue person = dctx.getDelegator().findOne("Person", false, "partyId", oisgToPrepare.getString("partyId"));
                order.put("customer", UtilMisc.toMap(
                        "id", person.get("partyId"),
                        "title", person.get("personalTitle"),
                        "firstName", person.get("firstName"),
                        "lastName", person.get("lastName")
                ));
                // items
                List<GenericValue> OISGAToPrepares = dctx.getDelegator().findByAnd("OISGAToPrepareView",
                        UtilMisc.toMap(
                                "orderId", oisgToPrepare.getString("orderId"),
                                "shipGroupSeqId", oisgToPrepare.getString("shipGroupSeqId")),
                        UtilMisc.toList("orderItemSeqId"),
                        false);

                List<Map<String, Object>> items = new ArrayList<Map<String, Object>>();

                for (GenericValue OISGAToPrepare : OISGAToPrepares) {

                    GenericValue orderItem = dctx.getDelegator().findOne(
                            "OrderItem",
                            UtilMisc.toMap(
                                    "orderId", oisgToPrepare.getString("orderId"),
                                    "orderItemSeqId", OISGAToPrepare.getString("orderItemSeqId")),
                            false);

                    items.add(UtilMisc.toMap(
                            "id", OISGAToPrepare.getString("orderItemSeqId"),
                            "product" , UtilMisc.toMap(
                                    "id", OISGAToPrepare.getString("productId"),
                                    "name", OISGAToPrepare.getString("internalName")),
                            "quantity", OISGAToPrepare.getBigDecimal("quantity"),
                            "status", OISGAToPrepare.getString("statusId"),
                            "price", orderItem.getBigDecimal("unitPrice")
                    ));
                }
                order.put("items", items);

                orders.add(order);

            }

            results.put("orders", orders);

        } catch(Exception e) {
            results = ServiceUtil.returnError("get order error : " + e.getMessage());
        }
        return results;
    }

    public static Map<String, Object> startOrderPreparation(DispatchContext dctx, Map<String, ? extends Object> context) {
        return updateOrder(dctx, context, "ORDER_SENT", "SAISIE_PROC_FOU");
    }

    public static Map<String, Object> finishOrderPreparation(DispatchContext dctx, Map<String, ? extends Object> context) {
        return updateOrder(dctx, context, "ORDER_PROCESS_PREP", "SAISIE_PREP_FOU");
    }

    private static Map<String, Object> updateOrder(DispatchContext dctx, Map<String, ? extends Object> context, String actualOrderStatus, String eventEnumId) {

        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {
            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));

            Object orderId = context.get("orderId");
            Object shipGroupSeqId = context.get("shipGroup");
            GenericValue oisgToPrepare = dctx.getDelegator().findOne("OISGToPrepareView", false,
                    "orderId", orderId,
                    "shipGroupSeqId", shipGroupSeqId);

            if (UtilValidate.isEmpty(oisgToPrepare)) {
                return ServiceUtil.returnError("unknow order ship group");
            }
            if (! login.getString("partyId").equals(oisgToPrepare.getString("supplierPartyId"))) {
                return ServiceUtil.returnError("user must be supplier of order ship group");
            }
            if (! actualOrderStatus.equals(oisgToPrepare.getString("statusId"))) {
                return ServiceUtil.returnError("order status must be '" + actualOrderStatus + "'");
            }

            Map<String, Object> params = UtilMisc.toMap(
                    "orderId", orderId,
                    "eventEnumId", eventEnumId,
                    "shipGroupSeqId", shipGroupSeqId,
                    "userLogin", login
            );

            List<GenericValue> OISGAToPrepares = dctx.getDelegator().findByAnd("OISGAToPrepareView",
                    UtilMisc.toMap(
                            "orderId", orderId,
                            "shipGroupSeqId", shipGroupSeqId),
                    UtilMisc.toList("orderItemSeqId"),
                    false);

            if ("SAISIE_PREP_FOU".equals(eventEnumId)) {
                //Call service to validate status automatically
                Map<String, Object> simpleOISGPrepCtx = dctx.makeValidContext("simpleOISGPrep", "IN", params);
                Map<String, Object> simpleOISGPrepResult = dctx.getDispatcher().runSync("simpleOISGPrep", simpleOISGPrepCtx);
                if (ServiceUtil.isError(simpleOISGPrepResult)) {
                    return simpleOISGPrepResult;
                }
            } else {
                for (GenericValue OISGAToPrepare : OISGAToPrepares) {
                    params.put("orderItemSeqId", OISGAToPrepare.getString("orderItemSeqId"));

                    Map<String, Object> updateOrderResult = dctx.getDispatcher().runSync("updateOrderFromEvent", params);
                    if (! ServiceUtil.isSuccess(updateOrderResult)) {
                        return updateOrderResult;
                    }
                }
            }

            oisgToPrepare = dctx.getDelegator().findOne("OISGToPrepareView", false,
                    "orderId", orderId,
                    "shipGroupSeqId", shipGroupSeqId);

            results.put("newStatus", oisgToPrepare.getString("statusId"));

        } catch (Exception e) {
            results = ServiceUtil.returnError("get order error : " + e.getMessage());
        }
        return results;
    }
    
    public static Map<String, Object> getOffers(DispatchContext dctx, Map<String, ? extends Object> context) {

        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {

            Locale locale = (Locale) context.get("locale");

            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));

            List<GenericValue> productOffers = dctx.getDelegator().findByAnd(
                    "ProductOffer",
                    UtilMisc.toMap("supplierPartyId", login.getString("partyId")),
                    UtilMisc.toList("productOfferId"),
                    false
            );

            List<Map<String, Object>> offers = new ArrayList<Map<String, Object>>(productOffers.size());

            for (GenericValue productOffer : productOffers) {

                offers.add(transformOffer(dctx, productOffer, locale));

            }

            results.put("offers", offers);


        } catch(Exception e) {
            results = ServiceUtil.returnError("get offers error : " + e.getMessage());
        }
        return results;

    }

    protected static Map<String, Object> transformOffer(DispatchContext dctx, GenericValue productOffer, Locale locale) throws GenericEntityException {

        GenericValue product = dctx.getDelegator().findOne(
                "Product",
                UtilMisc.toMap("productId", productOffer.getString("productId")),
                false
        );

        List<GenericValue> facilities = dctx.getDelegator().findByAnd(
                "ProductOfferFacility",
                UtilMisc.toMap("productOfferId", productOffer.getString("productOfferId")),
                UtilMisc.toList("facilityId"),
                false
        );

        List<String> facilityIds = new ArrayList<String>(facilities.size());

        for (GenericValue facility : facilities) {
            facilityIds.add(facility.getString("facilityId"));
        }

        List<GenericValue> productContents = dctx.getDelegator().findByAnd(
                "ProductContentAndInfo",
                UtilMisc.toMap(
                        "productId", productOffer.getString("productId"),
                        "productContentTypeId", "MAIN_IMAGE"),
                null,
                false);


        String productImage = "";
        if (! productContents.isEmpty()) {
            productImage = productContents.get(0).getString("drObjectInfo");
        }

        //search categories
        List<GenericValue> list = dctx.getDelegator().findByAnd(
                "ProductCategoryAndMember",
                UtilMisc.toMap(
                        "productId", product.getString("productId"),
                        "productCategoryTypeId", "SEARCH_CATEGORY"
                ),
                UtilMisc.toList("sequenceNum"),
                false);

        String categoryId = "";
        if (UtilValidate.isNotEmpty(list)) {
            categoryId = list.get(0).getString("productCategoryId");
        }

        //unité de vente
        GenericValue saleUnit = dctx.getDelegator().findOne("Enumeration", UtilMisc.toMap("enumId", product.getString("unitTypeEnumId")), false);

        Map<String, Object> unit = UtilMisc.toMap(
                "id", saleUnit.getString("enumId"),
                "description", saleUnit.get("description", locale)
        );

        Map<String, Object> productSmall = UtilMisc.toMap(
                "id", product.getString("productId"),
                "name", product.getString("productName"),
                "image", productImage,
                "categoryId", categoryId,
                "unit", unit
        );


        List<GenericValue> productOfferContents = dctx.getDelegator().findByAnd(
                "ProductOfferContentAndInfo",
                UtilMisc.toMap(
                        "productOfferId", productOffer.getString("productOfferId"),
                        "productContentTypeId", "MAIN_IMAGE"),
                null,
                false);

        Map<String, Object> mainImage = new HashMap<String, Object>();
        if (! productOfferContents.isEmpty()) {
            mainImage.put("fromDate", productOfferContents.get(0).getTimestamp("fromDate").getTime());
            mainImage.put("contentId", productOfferContents.get(0).getString("contentId"));
            mainImage.put("productContentTypeId", productOfferContents.get(0).getString("contentId"));
            mainImage.put("image", productOfferContents.get(0).getString("drObjectInfo"));
        }

        productOfferContents = dctx.getDelegator().findByAnd(
                "ProductOfferContentAndInfo",
                UtilMisc.toMap(
                        "productOfferId", productOffer.getString("productOfferId"),
                        "productContentTypeId", "MISC_IMAGE"),
                null,
                false);

        List<Map<String, Object>> miscImages = new ArrayList<Map<String,Object>>();

        for (GenericValue productOfferContent : productOfferContents) {
            Map<String, Object> miscImage = new HashMap<String, Object>();
            miscImage.put("contentId", productOfferContent.getString("contentId"));
            miscImage.put("fromDate", productOfferContent.getTimestamp("fromDate").getTime());
            miscImage.put("productContentTypeId", productOfferContent.getString("productContentTypeId"));
            miscImage.put("image", productOfferContent.get("drObjectInfo"));
            miscImages.add(miscImage);
        }

        Map<String, Object> offer = UtilMisc.toMap(
                "id", productOffer.getString("productOfferId"),
                "name", productOffer.getString("productOfferName"),
                "status", productOffer.getString("statusId"),
                "type", productOffer.getString("productOfferTypeId"),
                "fromDate", dateIsoFormat.format(productOffer.getTimestamp("fromDate")),
                "thruDate", productOffer.getTimestamp("thruDate") == null ? null : dateIsoFormat.format(productOffer.getTimestamp("thruDate")),
                "price", productOffer.getBigDecimal("consumerSalePrice"),
                "facilityIds", facilityIds,
                "product", productSmall,
                "mainImage", mainImage,
                "miscImages", miscImages,
                "commercialArgument", getProductOfferContent(dctx, productOffer.getString("productOfferId"), "ARG_COM"),
                "conseilUtil", getProductOfferContent(dctx, productOffer.getString("productOfferId"), "CONSEIL_UTIL"),
                "composition", getProductOfferContent(dctx, productOffer.getString("productOfferId"), "COMPOSITION")
        );
        if ("DROP".equals(productOffer.get("productOfferTypeId")) && "OFFER_VALIDATED".equals(productOffer.getString("statusId"))) {
            BigDecimal remainingQty = productOffer.getBigDecimal("remainingQty");
            if (UtilValidate.isNotEmpty(remainingQty)) {
                offer.put("quantity", remainingQty);
            } else {
                offer.put("quantity", productOffer.getBigDecimal("quantity"));
            }
        } else {
            offer.put("quantity", productOffer.getBigDecimal("quantity"));
        }

        return offer;

    }

    public static Map<String, Object> getOffer(DispatchContext dctx, Map<String, ? extends Object> context) {

        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {

            Locale locale = (Locale) context.get("locale");

            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));

            GenericValue productOffer = dctx.getDelegator().findOne(
                    "ProductOffer",
                    UtilMisc.toMap("productOfferId", context.get("offerId")),
                    false
            );

//            ProductOfferContent
//            ProductContent


            if (UtilValidate.isEmpty(productOffer)) {
                return ServiceUtil.returnError("offer unknown");
            }

            if (! login.getString("partyId").equals(productOffer.getString("supplierPartyId"))) {
                return ServiceUtil.returnError("offer unknown for this supplier");
            }

            results.put("offer", transformOffer(dctx, productOffer, locale));


        } catch(Exception e) {
            e.printStackTrace();
            results = ServiceUtil.returnError("get offer error : " + e.getMessage());
        }
        return results;

    }

    protected static List<Map<String, Object>> getFacilities(DispatchContext dctx,  String supplierPartyId) throws GenericEntityException {
        List<GenericValue> roofs = dctx.getDelegator().findList(
                "FacilityParty",
                EntityCondition.makeCondition(
                        UtilMisc.toList(
                                EntityCondition.makeCondition("partyId", EntityComparisonOperator.EQUALS, supplierPartyId),
                                EntityCondition.makeCondition("roleTypeId", EntityComparisonOperator.EQUALS, "SUPPLIER"),
                                EntityUtil.getFilterByDateExpr()
                        ),
                        EntityJoinOperator.AND),
                UtilMisc.toSet("facilityId"),
                UtilMisc.toList("facilityId"),
                new EntityFindOptions(true, EntityFindOptions.TYPE_SCROLL_INSENSITIVE, EntityFindOptions.CONCUR_READ_ONLY, -1, 0, true),
                false
        );
        List<Map<String, Object>> facilities = new ArrayList<Map<String, Object>>(roofs.size());
        for(GenericValue roof: roofs) {

            List<GenericValue> roofAndMechs = dctx.getDelegator().findList(
                    "FacilityAndContactMech",
                    EntityCondition.makeCondition(
                            UtilMisc.toList(
                                    EntityCondition.makeCondition("facilityId", EntityComparisonOperator.EQUALS, roof.getString("facilityId")),
                                    EntityCondition.makeCondition("contactMechTypeId", EntityComparisonOperator.EQUALS, "POSTAL_ADDRESS"),
                                    EntityUtil.getFilterByDateExpr()
                            ),
                            EntityJoinOperator.AND),
                    UtilMisc.toSet("facilityId", "facilityName", "contactMechId"),
                    UtilMisc.toList("facilityId"),
                    new EntityFindOptions(true, EntityFindOptions.TYPE_SCROLL_INSENSITIVE, EntityFindOptions.CONCUR_READ_ONLY, -1, 0, true),
                    false
            );

            if (!roofAndMechs.isEmpty()) {

                GenericValue pa = dctx.getDelegator().findOne("PostalAddress", false, "contactMechId", roofAndMechs.get(0).getString("contactMechId"));
                if (UtilValidate.isNotEmpty(pa)) {
                    Map<String, Object> oneRoof = UtilMisc.toMap(
                            "facilityId", roof.getString("facilityId"),
                            "facilityName", roofAndMechs.get(0).getString("facilityName"),
                            "address1", UtilValidate.isNotEmpty(pa.getString("address1")) ? pa.getString("address1") : "",
                            "address2", UtilValidate.isNotEmpty(pa.getString("address2")) ? pa.getString("address2") : "",
                            "postalCode", UtilValidate.isNotEmpty(pa.getString("postalCode")) ? pa.getString("postalCode") : "",
                            "city", UtilValidate.isNotEmpty(pa.getString("city")) ? pa.getString("city") : "",
                            "countryGeoId", UtilValidate.isNotEmpty(pa.getString("countryGeoId")) ? pa.getString("countryGeoId") : ""
                    );
                    facilities.add(oneRoof);
                }

            }
        }
        return facilities;
    }


    public static Map<String, Object> getOfferValuesSet(DispatchContext dctx, Map<String, ? extends Object> context) {

        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {
            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));
            // roofs
            results.put("roofs", getFacilities(dctx, login.getString("partyId")));

            //catégories
            EntityCondition cond = EntityCondition.makeCondition(
                    UtilMisc.toList(
                            EntityCondition.makeCondition("productCategoryTypeId", EntityComparisonOperator.EQUALS, "SEARCH_CATEGORY"),
                            EntityCondition.makeCondition("productCategoryId", EntityComparisonOperator.IN, UtilMisc.toList("FO11", "FO12", "FO13", "FO14"))
                    ),
                    EntityJoinOperator.AND);

            Set<String> columns = UtilMisc.toSet("productCategoryId", "categoryName");

            List<GenericValue> catList = dctx.getDelegator().findList(
                    "ProductCategory",
                    cond,
                    columns,
                    UtilMisc.toList("productCategoryId"), null, true);

            List<Map<String, Object>> categories = new ArrayList<Map<String,Object>>();

            for (GenericValue cat : catList) {

                List<Map<String, Object>> children = getCategoryChildren(dctx, cat.getString("productCategoryId"));

                categories.add(UtilMisc.toMap(
                        "id", cat.getString("productCategoryId"),
                        "name", cat.getString("categoryName"),
                        "children", children
                ));
            }


            results.put("categories", categories);

            return results;

        } catch(Exception e) {
            results = ServiceUtil.returnError("get offers error : " + e.getMessage());
        }
        return results;

    }


    public static class ProductStringConstraint extends ProductSearch.ProductSearchConstraint {

        public static final String constraintName = " ProductString";
        protected String keyword;
        protected boolean igoreCase;
        protected String[] productFieldNames;

        public ProductStringConstraint(String keyword, boolean igoreCase, String... productFieldNames) {
            this.keyword = keyword;
            this.igoreCase = igoreCase;
            this.productFieldNames = productFieldNames;
        }

        @Override
        public void addConstraint(ProductSearch.ProductSearchContext productSearchContext) {
            List<EntityCondition> conditionMatch = new ArrayList<EntityCondition>(productFieldNames.length);
            for (String productFieldName : productFieldNames) {
                productSearchContext.dynamicViewEntity.addAlias("PROD", productFieldName, null, null, null, null, null);
                if (igoreCase) {
                    conditionMatch.add(EntityCondition.makeCondition(
                            EntityFunction.UPPER_FIELD(productFieldName),
                            EntityOperator.LIKE,
                            EntityFunction.UPPER("%" + keyword + "%")
                    ));
                } else {
                    conditionMatch.add(EntityCondition.makeCondition(
                            productFieldName,
                            EntityOperator.LIKE,
                            "%" + keyword + "%"
                    ));
                }

            }

            productSearchContext.entityConditionList.add(EntityCondition.makeCondition(conditionMatch, EntityOperator.OR));
            productSearchContext.productSearchConstraintList.add(productSearchContext.getDelegator().makeValue("ProductSearchConstraint", UtilMisc.toMap("constraintName", constraintName, "infoString", this.keyword)));
        }

        @Override
        public String prettyPrintConstraint(Delegator delegator, boolean detailed, Locale locale) {
            return UtilProperties.getMessage(ProductSearch.resource, "ProductString", locale);
        }


    }

    public static List<Map<String, Object>> getCategoryChildren(DispatchContext dctx, String parentProductCategoryId) throws GenericEntityException {

        EntityCondition cond = EntityCondition.makeCondition(
                UtilMisc.toList(
                        EntityUtil.getFilterByDateExpr(),
                        EntityCondition.makeCondition("productCategoryTypeId", EntityComparisonOperator.EQUALS, "SEARCH_CATEGORY"),
                        EntityCondition.makeCondition("parentProductCategoryId", EntityComparisonOperator.EQUALS, parentProductCategoryId)
                ),
                EntityJoinOperator.AND);

        Set<String> columns = UtilMisc.toSet("productCategoryId", "categoryName");

        List<GenericValue> catList = dctx.getDelegator().findList(
                "ProductCategoryRollupAndChild",
                cond,
                columns,
                UtilMisc.toList("productCategoryId"), null, true);

        List<Map<String, Object>> categories = new ArrayList<Map<String,Object>>();

        for (GenericValue cat : catList) {

            List<Map<String, Object>> children = getCategoryChildren(dctx, cat.getString("productCategoryId"));

            categories.add(UtilMisc.toMap(
                    "id", cat.getString("productCategoryId"),
                    "name", cat.getString("categoryName"),
                    "children", children
            ));
        }

        return categories;
    }


    public static Map<String, Object> searchProduct(DispatchContext dctx, Map<String, ? extends Object> context) {

        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {
            Locale locale = (Locale) context.get("locale");

            String searchValue = (String) context.get("search");

            if (searchValue.length() < 3) {
                return ServiceUtil.returnError("Search product : search value length must be greater than 2 caracters");
            }

            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));

            List<ProductSearch.ProductSearchConstraint> productSearchConstraintList = FastList.newInstance();

            if (UtilValidate.isNotEmpty(context.get("categoryId"))) {
                productSearchConstraintList.add(new ProductSearch.CategoryConstraint((String) context.get("categoryId"), true, null));
            }

            productSearchConstraintList.add(new ProductStringConstraint(searchValue, true, "productId", "productName"));

            // TODO Bavencoff 20/01/2016 il faut filtrer aussi sur les produit que peut vendre le fournisseur
            productSearchConstraintList.add(new ProductSearch.SupplierConstraint(login.getString("partyId")));

            List<String> productIds = ProductSearch.searchProducts(productSearchConstraintList, new ProductSearch.SortKeywordRelevancy(), dctx.getDelegator(), null, null);

            int limit = (Integer) context.get("limit");

            if (productIds.size() > limit) {
                productIds = productIds.subList(0, limit);
            }

            List<Map<String, Object>> products = new ArrayList<Map<String, Object>>(productIds.size());

            for (String productId : productIds) {
                GenericValue product = dctx.getDelegator().findOne(
                        "Product",
                        UtilMisc.toMap("productId", productId),
                        false
                );

                List<GenericValue> productContents = dctx.getDelegator().findByAnd(
                        "ProductContentAndInfo",
                        UtilMisc.toMap(
                                "productId", productId,
                                "productContentTypeId", "MAIN_IMAGE"),
                        null,
                        false);

                String image = "";
                if (! productContents.isEmpty()) {
                    image = productContents.get(0).getString("drObjectInfo");
                }

                //unité de vente
                GenericValue saleUnit = dctx.getDelegator().findOne("Enumeration", UtilMisc.toMap("enumId", product.getString("unitTypeEnumId")), false);

                Map<String, Object> unit = UtilMisc.toMap(
                        "id", saleUnit.getString("enumId"),
                        "description", saleUnit.get("description", locale)
                );

                products.add(UtilMisc.toMap(
                        "id", productId,
                        "name", product.getString("productName"),
                        "image", image ,
                        "unit", unit
                ));

            }

            results.put("products", products);

        } catch(Exception e) {
            results = ServiceUtil.returnError("search product error : " + e.getMessage());
        }
        return results;
    }

    public static Map<String, Object> saveOffer(DispatchContext dctx, Map<String, ? extends Object> context) {
        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {

            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));

            List<String> facilityIds = UtilMisc.toListArray(((String) context.get("facilityIds")).split(","));

            Object offerId = context.get("offerId");

            if (offerId != null) { // update

                GenericValue productOffer = dctx.getDelegator().findOne(
                        "ProductOffer",
                        UtilMisc.toMap("productOfferId", offerId),
                        false
                );

                Map<String, Object> updateParams = UtilMisc.toMap(
                        "userLogin", login,
                        "productOfferId", offerId,
                        "supplierPartyId", login.getString("partyId"),
                        "catalogSupplierPrice", context.get("price").toString(),
                        "purchasePrice", context.get("price").toString(),
                        "consumerSalePrice", context.get("price").toString(),
                        "quantity", context.get("quantity"),
                        "statusId", productOffer.getString("statusId"),
                        "offerEditLevel", 1l
                );


                if ("OFFER_NOT_READY".equals(productOffer.getString("statusId"))
                        || "OFFER_PENDING".equals(productOffer.getString("statusId"))) {
                    updateParams.putAll(UtilMisc.toMap(
                            "productOfferName", context.get("name"),
                            "productOfferTypeId", context.get("type"),
                            "productId", context.get("productId"),
                            "fromDate", context.get("fromDate"),
                            "thruDate", context.get("thruDate"),
                            "facilityId", facilityIds.get(0),
                            "offerEditLevel", 1l
                    ));
                } else if ("OFFER_VALIDATED".equals(productOffer.getString("statusId"))) {
                    BigDecimal quantity = productOffer.getBigDecimal("quantity");
                    BigDecimal remainingQty = (BigDecimal) context.get("quantity");
                    updateParams.putAll(UtilMisc.toMap(
                            "productOfferName", context.get("name"),
                            "productOfferTypeId", context.get("type"),
                            "productId", context.get("productId"),
                            "fromDate", context.get("fromDate"),
                            "thruDate", context.get("thruDate"),
                            "facilityId", facilityIds.get(0),
                            "quantity", quantity,
                            "remainingQty", remainingQty));
                }

                Map<String, Object> updateProductOfferResult = dctx.getDispatcher().runSync("updateProductOffer", updateParams);
                if (! ServiceUtil.isSuccess(updateProductOfferResult)) {
                    return updateProductOfferResult;
                }

                //supression des toit
                List<GenericValue> facilities = dctx.getDelegator().findByAnd(
                        "ProductOfferFacility",
                        UtilMisc.toMap("productOfferId", productOffer.getString("productOfferId")),
                        UtilMisc.toList("facilityId"),
                        false
                );

                for (GenericValue facility : facilities) {
                    if (! facilityIds.contains(facility.getString("facilityId"))) {
                        Map<String, Object> removeFacilityParams = UtilMisc.toMap(
                                "userLogin", login,
                                "productOfferId", offerId,
                                "facilityId", facility.getString("facilityId")
                        );

                        Map<String, Object> removeFacilityResult = dctx.getDispatcher().runSync("removeFacilityFromProductOffer", removeFacilityParams);
                        if (! ServiceUtil.isSuccess(removeFacilityResult)) {
                            return removeFacilityResult;
                        }
                    } else {
                        facilityIds.remove(facility.getString("facilityId"));
                    }
                }

                // Ajout des toit restants
                for (String facilityId : facilityIds) {
                    Map<String, Object> addFacilityParams = UtilMisc.toMap(
                            "userLogin", login,
                            "productOfferId", offerId,
                            "facilityId", facilityId,
                            "fromDate", context.get("fromDate"),
                            "thruDate", context.get("thruDate")
                    );

                    Map<String, Object> addFacilityResult = dctx.getDispatcher().runSync("addFacilityToOffer", addFacilityParams);
                    if (! ServiceUtil.isSuccess(addFacilityResult)) {
                        return addFacilityResult;
                    }
                }


            } else { // create

                // creation de l'offre
                Map<String, Object> createParams = UtilMisc.toMap(
                        "userLogin", login,
                        "productOfferName", context.get("name"),
                        "productOfferTypeId", context.get("type"),
                        "productId", context.get("productId"),
                        "supplierPartyId", login.getString("partyId"),
                        "catalogSupplierPrice", context.get("price"),
                        "purchasePrice", context.get("price").toString(),
                        "consumerSalePrice", context.get("price").toString(),
                        "quantity", context.get("quantity").toString(),
                        "statusId", "OFFER_NOT_READY",
                        "fromDate", context.get("fromDate"),
                        "thruDate", context.get("thruDate"),
                        "facilityId", facilityIds.get(0),
                        "isSupplierPortal", "true"
                );

                Map<String, Object> createProductOfferResult = dctx.getDispatcher().runSync("createProductOffer", createParams);
                if (! ServiceUtil.isSuccess(createProductOfferResult)) {
                    return createProductOfferResult;
                }

                //Ajout des autre toits
                facilityIds.remove(0);
                for (String facilityId : facilityIds) {
                    Map<String, Object> addFacilityParams = UtilMisc.toMap(
                            "userLogin", login,
                            "productOfferId", createProductOfferResult.get("productOfferId"),
                            "facilityId", facilityId,
                            "fromDate", context.get("fromDate"),
                            "thruDate", context.get("thruDate")
                    );

                    Map<String, Object> addFacilityResult = dctx.getDispatcher().runSync("addFacilityToOffer", addFacilityParams);
                    if (! ServiceUtil.isSuccess(addFacilityResult)) {
                        return addFacilityResult;
                    }
                }

                offerId = createProductOfferResult.get("productOfferId");

            }

            results.put("offerId", offerId);

        } catch(Exception e) {
            results = ServiceUtil.returnError("update offer error : " + e.getMessage());
        }
        return results;
    }

    public static Map<String, Object> askValidationOffer(DispatchContext dctx, Map<String, ? extends Object> context) {
        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {

            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));

            Object offerId = context.get("offerId");

            GenericValue productOffer = dctx.getDelegator().findOne(
                    "ProductOffer",
                    UtilMisc.toMap("productOfferId", offerId),
                    false
            );

            if (! "OFFER_NOT_READY".equals(productOffer.getString("statusId"))) {
                return ServiceUtil.returnError("demande de validation d'une offre : la status de l'offre n'est pas en cours de saisie");
            }

            Map<String, Object> updateParams = UtilMisc.toMap(
                    "userLogin", login,
                    "productOfferId", offerId,
                    "productOfferName", productOffer.get("productOfferName"),
                    "productOfferTypeId", productOffer.get("productOfferTypeId"),
                    "productId", productOffer.get("productId"),
                    "supplierPartyId", login.getString("partyId"),
                    "catalogSupplierPrice", productOffer.get("catalogSupplierPrice").toString(),
                    "purchasePrice", productOffer.get("purchasePrice").toString(),
                    "consumerSalePrice", productOffer.get("consumerSalePrice").toString(),
                    "quantity", productOffer.get("quantity"),
                    "fromDate", productOffer.get("fromDate").toString(),
                    "thruDate", productOffer.get("thruDate") == null ? null : productOffer.get("thruDate").toString(),
                    "statusId", "OFFER_PENDING",
                    "offerEditLevel", 1l
            );


            Map<String, Object> updateProductOfferResult = dctx.getDispatcher().runSync("updateProductOffer", updateParams);
            if (! ServiceUtil.isSuccess(updateProductOfferResult)) {
                return updateProductOfferResult;
            }

            results.put("offerId", offerId);

        } catch(Exception e) {
            results = ServiceUtil.returnError("demande de validation d'une offre : " + e.getMessage());
        }
        return results;
    }

    public static Map<String, Object> uploadImageOffer(DispatchContext dctx, Map<String, ? extends Object> context) {
        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {

            Map<String, Object> authToken = checkAuthToken(dctx, context);
            if (!ServiceUtil.isSuccess(authToken)) {
                return authToken;
            }

            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", authToken.get("username"));

            Object offerId = context.get("offerId");

            GenericValue productOffer = dctx.getDelegator().findOne(
                    "ProductOffer",
                    UtilMisc.toMap("productOfferId", offerId),
                    false
            );

            if (! "OFFER_NOT_READY".equals(productOffer.getString("statusId"))) {
                return ServiceUtil.returnError("Téléversement d'une image : la status de l'offre n'est pas en cours de saisie");
            }

            // téléversement de l'image
            if (context.get("imageFile") != null) {
                Map<String, Object> addImageParams = UtilMisc.toMap(
                        "userLogin", login,
                        "productOfferId", context.get("offerId"),
                        "productContentTypeId", ((Boolean) context.get("mainImage")) ? "MAIN_IMAGE" : "MISC_IMAGE",
                        "uploadedFile", context.get("imageFile"),
                        "_uploadedFile_fileName", context.get("_imageFile_fileName"),
                        "_uploadedFile_contentType", context.get("_imageFile_contentType")
                );

                Map<String, Object> addImageResult = dctx.getDispatcher().runSync("addOtoitImageForProductOffer", addImageParams);
                if (!ServiceUtil.isSuccess(addImageResult)) {
                    return addImageResult;
                }
            }

            List<GenericValue> productOfferContents = dctx.getDelegator().findByAnd(
                    "ProductOfferContentAndInfo",
                    UtilMisc.toMap(
                            "productOfferId", context.get("offerId"),
                            "productContentTypeId", ((Boolean) context.get("mainImage")) ? "MAIN_IMAGE" : "MISC_IMAGE",
                            "drDataResourceName", context.get("_imageFile_fileName")),
                    null,
                    false);

            results.put("contentId", productOfferContents.get(0).getString("contentId"));
            results.put("image", productOfferContents.get(0).getString("drObjectInfo"));

            return results;


        } catch(Exception e) {
            results = ServiceUtil.returnError("upload image offer error : " + e.getMessage());
        }
        return results;
    }

    public static Map<String, Object> deleteOffer(DispatchContext dctx, Map<String, ? extends Object> context) {
        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {

            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));

            GenericValue offer = dctx.getDelegator().findOne("ProductOffer", UtilMisc.toMap("productOfferId", context.get("offerId")), false);
            List<GenericValue> offerContents = offer.getRelated("ProductOfferContent", null, null, false);

            for (GenericValue offerContent : offerContents) {
                offerContent.remove();
            }

            Map<String, Object> deleteParams = UtilMisc.toMap(
                    "userLogin", login,
                    "productOfferId", context.get("offerId")
            );

            Map<String, Object> deleteProductOfferResult = dctx.getDispatcher().runSync("deleteProductOffer", deleteParams);
            if (! ServiceUtil.isSuccess(deleteProductOfferResult)) {
                return deleteProductOfferResult;
            }

        } catch(Exception e) {
            results = ServiceUtil.returnError("update offer error : " + e.getMessage());
        }
        return results;
    }

   public static Map<String, Object> getDashboard(DispatchContext dctx, Map<String, ? extends Object> context) {
        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {

            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));

            // counts
            // TODO Bavencoff 09/02/2016 bouchon pour les sommes
            results.put("counts", UtilMisc.toMap(
                    "orders", 128,
                    "productSales", 549,
                    "costumers", 47));


            // Alerts
            // TODO Bavencoff 08/02/2016 bouchon pour la recupération des alert;
            List<Map<String, Object>> alerts = UtilGenerics.checkList(UtilMisc.toList(
                    UtilMisc.toMap(
                            "typeId", "OFFER_NO_ORDER",
                            "offer", UtilMisc.toMap(
                                    "id", "",
                                    "name", "Salsifis")
                    ),
                    UtilMisc.toMap(
                            "typeId", "OFFER_FULL",
                            "offer", UtilMisc.toMap(
                                    "id", "",
                                    "name", "Miel des bois")
                    ),
                    UtilMisc.toMap(
                            "typeId", "SUMMER_SOON"
                    )
            ));
            results.put("alerts", alerts);


            // commande en cours

            int preparedOrders = dctx.getDelegator().findList(
                    "OISGToPrepareViewRoof",
                    EntityCondition.makeCondition(
                            UtilMisc.toList(
                                    EntityCondition.makeCondition("supplierPartyId", EntityComparisonOperator.EQUALS, login.getString("partyId")),
                                    EntityCondition.makeCondition("statusId", EntityComparisonOperator.EQUALS, "ORDER_PREPARED"),
                                    EntityCondition.makeCondition("shipmentMethodTypeId", EntityComparisonOperator.EQUALS, "DROP_SHIP_ROOF")
                            ),
                            EntityJoinOperator.AND),
                    null,
                    UtilMisc.toList("orderDate"),
                    new EntityFindOptions(true, EntityFindOptions.TYPE_SCROLL_INSENSITIVE, EntityFindOptions.CONCUR_READ_ONLY, -1, 0, true),
                    false
            ).size();

            long orderSent = dctx.getDelegator().findList(
                    "OISGToPrepareViewRoof",
                    EntityCondition.makeCondition(
                            UtilMisc.toList(
                                    EntityCondition.makeCondition("supplierPartyId", EntityComparisonOperator.EQUALS, login.getString("partyId")),
                                    EntityCondition.makeCondition("statusId", EntityComparisonOperator.IN, UtilMisc.toList("ORDER_SENT", "ORDER_PROCESS_PREP")),
                                    EntityCondition.makeCondition("shipmentMethodTypeId", EntityComparisonOperator.EQUALS, "DROP_SHIP_ROOF")
                            ),
                            EntityJoinOperator.AND),
                    null,
                    UtilMisc.toList("orderDate"),
                    new EntityFindOptions(true, EntityFindOptions.TYPE_SCROLL_INSENSITIVE, EntityFindOptions.CONCUR_READ_ONLY, -1, 0, true),
                    false
            ).size();

            long lateOrders = dctx.getDelegator().findList(
                    "OISGToPrepareViewRoof",
                    EntityCondition.makeCondition(
                            UtilMisc.toList(
                                    EntityCondition.makeCondition("supplierPartyId", EntityComparisonOperator.EQUALS, login.getString("partyId")),
                                    EntityCondition.makeCondition("statusId", EntityComparisonOperator.IN, UtilMisc.toList("ORDER_SENT", "ORDER_PROCESS_PREP", "ORDER_PREPARED")),
                                    EntityCondition.makeCondition("shipmentMethodTypeId", EntityComparisonOperator.EQUALS, "DROP_SHIP_ROOF"),
                                    EntityCondition.makeCondition("estimatedDeliveryDate", EntityComparisonOperator.LESS_THAN, UtilDateTime.nowTimestamp())
                            ),
                            EntityJoinOperator.AND),
                    null,
                    UtilMisc.toList("orderDate"),
                    new EntityFindOptions(true, EntityFindOptions.TYPE_SCROLL_INSENSITIVE, EntityFindOptions.CONCUR_READ_ONLY, -1, 0, true),
                    false
            ).size();

            results.put("orders", UtilMisc.toMap(
                    "prepared", preparedOrders,
                    "sent", orderSent,
                    "late", lateOrders)
            );

            // Chiffre d'affaire par toit pour les 12 denier mois

            List<Map<String, Object>> facilities = getFacilities(dctx, login.getString("partyId"));

            Timestamp now = UtilDateTime.nowTimestamp();

            //TODO Bavencoff 08/02/2016 Supprimer le random et les varibla qui l'utilise (utili uniquement pour le bouchon
            Random random = new Random(now.getTime());

            List<Map<String, Object>> turnoversByFacility = new LinkedList<>();

            for (Map<String, Object> facility : facilities) {

                double base = 500 + 400 * random.nextDouble();
                double rang = 400 + 400 * random.nextDouble();
                double offset = Math.PI * random.nextDouble();
                double period = Math.PI * (1 + random.nextDouble());

                List<Map<String, Object>> turnoversByMonth = new ArrayList<Map<String,Object>>();

                for (int previousMonth = 11; previousMonth >= 0; previousMonth--) {
                    Map<String, Object> s = new HashMap<String, Object>();
                    Timestamp start = UtilDateTime.getMonthStart(now, 0, -1 * previousMonth);
                    s.put("month", dateIsoFormat.format(start));
                    Timestamp end = UtilDateTime.getMonthEnd(start, TimeZone.getDefault(), Locale.getDefault());

                    // TODO Bavencoff 08/02/2016 chercher le chiffre d'affair pour ce toit et cette période
                    BigDecimal turnover = new BigDecimal(base + rang * Math.sin(offset + (previousMonth / 12d * period)));
                    turnover.setScale(2, RoundingMode.HALF_UP);
                    turnover = turnover.abs();
                    s.put("turnover", turnover);
                    turnoversByMonth.add(s);

                }

                turnoversByFacility.add(UtilMisc.toMap(
                        "facility", facility,
                        "turnoversByMonth", turnoversByMonth
                ));

            }
            results.put("turnovers", turnoversByFacility);


        } catch(Exception e) {
            results = ServiceUtil.returnError("get dashboard error : " + e.getMessage());
        }
        return results;
    }
    
    protected static Map<String, Object> getProductOfferContent(DispatchContext dctx, String productOfferId, String productContentTypeId) throws GenericEntityException {
        String contentText = null;

        List<GenericValue> productOfferContents = dctx.getDelegator().findByAnd(
                "ProductOfferContentAndInfo",
                UtilMisc.toMap(
                        "productOfferId", productOfferId,
                        "productContentTypeId", productContentTypeId),
                        null,
                        false); 
        
        String dataRessourceId = null;
        Long fromDate = null;
        String contentId = "";
        productOfferContents = EntityUtil.filterByDate(productOfferContents);
        if (UtilValidate.isNotEmpty(productOfferContents)){
            GenericValue productOfferContent = EntityUtil.getFirst(productOfferContents);
            dataRessourceId = productOfferContent.getString("drDataResourceId");
            fromDate = productOfferContent.getTimestamp("fromDate").getTime();
            contentId = productOfferContent.getString("contentId");
       } else {
               GenericValue productOffer = dctx.getDelegator().findOne("ProductOffer", UtilMisc.toMap("productOfferId",productOfferId), false);
               List<GenericValue> productContents = dctx.getDelegator().findByAnd(
                       "ProductContentAndInfo",
                       UtilMisc.toMap(
                               "productId", productOffer.get("productId").toString(),
                               "productContentTypeId", productContentTypeId),
                               null,
                               false); 
               productContents = EntityUtil.filterByDate(productContents);
               
               if(UtilValidate.isNotEmpty(productContents)){
                   productContents = EntityUtil.filterByDate(productContents);
                   GenericValue productContent = EntityUtil.getFirst(productContents);
                   dataRessourceId = productContent.getString("drDataResourceId");
               }
               
           }
        if (dataRessourceId != null) {
            GenericValue electronicTextOffer = dctx.getDelegator().findOne("ElectronicText", UtilMisc.toMap("dataResourceId",dataRessourceId), false);
            contentText = electronicTextOffer.getString("textData");
        }
        return UtilMisc.toMap(
                "textData", contentText,
                "contentId", contentId,
                "fromDate", fromDate,
                "productContentTypeId", productContentTypeId
                );
    }

    public static Map<String, Object> uploadPdfOffer(DispatchContext dctx, Map<String, ? extends Object> context) {
        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {

            Map<String, Object> authToken = checkAuthToken(dctx, context);
            if (!ServiceUtil.isSuccess(authToken)) {
                return authToken;
            }

            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", authToken.get("username"));

            Object offerId = context.get("offerId");

            GenericValue productOffer = dctx.getDelegator().findOne(
                    "ProductOffer",
                    UtilMisc.toMap("productOfferId", offerId),
                    false
            );

            if (! "OFFER_NOT_READY".equals(productOffer.getString("statusId"))) {
                return ServiceUtil.returnError("Téléversement d'un pdf : la status de l'offre n'est pas en cours de saisie");
            }

            // téléversement du pdf
            if (context.get("pdfFile") != null) {
                Map<String, Object> addPdfParams = UtilMisc.toMap(
                        "userLogin", login,
                        "productOfferId", context.get("offerId"),
                        "productId","",
                        "productContentTypeId", "FRONT_PDF",
                        "uploadedFile", context.get("pdfFile"),
                        "_uploadedFile_fileName", context.get("_pdfFile_fileName"),
                        "_uploadedFile_contentType", context.get("_pdfFile_contentType"),
                        "entityName" , "ProductOffer"
                );

                Map<String, Object> addPdfResult = dctx.getDispatcher().runSync("uploadEntityContentFile", addPdfParams);
                if (!ServiceUtil.isSuccess(addPdfResult)) {
                    return addPdfResult;
                }
            }

            List<GenericValue> productOfferContents = dctx.getDelegator().findByAnd(
                    "ProductOfferContentAndInfo",
                    UtilMisc.toMap(
                            "productOfferId", context.get("offerId"),
                            "productContentTypeId", "FRONT_PDF"),
                    null,
                    false);

            results.put("pdf", productOfferContents.get(0).getString("drObjectInfo"));

            return results;


        } catch(Exception e) {
            results = ServiceUtil.returnError("erreur sur le upload des fichiers pdf: " + e.getMessage());
        }
        return results;
    }
    public static Map<String, Object> deleteOfferContent(DispatchContext dctx, Map<String, ? extends Object> context) {
        try {
            Long fromDateMillis = Long.valueOf((String)context.get("fromDate"));
            Timestamp fromDate = UtilDateTime.getTimestamp(fromDateMillis);
            GenericValue userLogin = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));
            Map<String, Object> deleteCtx = dctx.makeValidContext("deleteOtoitProductOfferImage", "IN", context);
            deleteCtx.putAll(
                    UtilMisc.toMap(
                    "fromDate", fromDate,
                    "productOfferId", context.get("offerId"),
                    "userLogin", userLogin
                    ));
            return dctx.getDispatcher().runSync("deleteOtoitProductOfferImage", deleteCtx);
        }
        catch(Exception e) {
            return ServiceUtil.returnError("error deleting offer content");
        }
    }
    public static Map<String, Object> saveOfferText(DispatchContext dctx, Map<String, ? extends Object> context) {
        try {
            String contentId = (String) context.get("contentId");
            Long fromDateMillis = null;
            Timestamp fromDate = null;
            if (UtilValidate.isNotEmpty(context.get("fromDate"))) {
                fromDateMillis = (Long)context.get("fromDate");
                fromDate = UtilDateTime.getTimestamp(fromDateMillis);
            }
            GenericValue userLogin = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", context.get("username"));
            Map<String, Object> serviceCtx = null;
            String serviceName = "createEntityHtmlContent";
            if (UtilValidate.isEmpty(contentId)) {
                serviceCtx = dctx.makeValidContext(serviceName, "IN", context);
                serviceCtx.put("mimeTypeId", "text/html");
            }
            else {
                serviceName = "updateEntityHtmlContent";
                serviceCtx = dctx.makeValidContext(serviceName, "IN", context);
                serviceCtx.putAll(
                        UtilMisc.toMap(
                                "fromDate", fromDate,
                                "userLogin", userLogin
                  ));
            }
            serviceCtx.put("userLogin", userLogin);
            serviceCtx.put("productOfferId", context.get("offerId"));
            serviceCtx.put("entityName", "ProductOffer");
            Map<String, Object> results = dctx.getDispatcher().runSync(serviceName, serviceCtx);
            if (ServiceUtil.isError(results)) return results;

            results = ServiceUtil.returnSuccess();
            if (UtilValidate.isEmpty(contentId)) {
                Map<String, Object> newContent = getProductOfferContent(dctx, (String)context.get("offerId"), (String)context.get("productContentTypeId"));
                results.put("fromDate", newContent.get("fromDate"));
                results.put("contentId", newContent.get("contentId"));
            }
            return results;
        }
        catch(Exception e) {
            e.printStackTrace();
            return ServiceUtil.returnError("error saving offer text");
        }
    }
    public static Map<String, Object> uploadOfferFile(DispatchContext dctx, Map<String, ? extends Object> context) {
        try {

            Map<String, Object> authToken = checkAuthToken(dctx, context);
            if (!ServiceUtil.isSuccess(authToken)) {
                return authToken;
            }

            GenericValue login = dctx.getDelegator().findOne("UserLogin", false, "userLoginId", authToken.get("username"));

            Object offerId = context.get("offerId");

            GenericValue productOffer = dctx.getDelegator().findOne(
                    "ProductOffer",
                    UtilMisc.toMap("productOfferId", offerId),
                    false
            );

            if (! "OFFER_NOT_READY".equals(productOffer.getString("statusId"))) {
                return ServiceUtil.returnError("Téléversement d'une image : la status de l'offre n'est pas en cours de saisie");
            }

            // téléversement de l'image
            if (context.get("offerFile") != null) {
                Map<String, Object> addImageParams = UtilMisc.toMap(
                        "userLogin", login,
                        "productOfferId", context.get("offerId"),
                        "productContentTypeId", "MISC_FILE",
                        "uploadedFile", context.get("offerFile"),
                        "_uploadedFile_fileName", context.get("_offerFile_fileName"),
                        "_uploadedFile_contentType", context.get("_offerFile_contentType")
                );

                Map<String, Object> results = dctx.getDispatcher().runSync("addOtoitImageForProductOffer", addImageParams);
                if (!ServiceUtil.isSuccess(results)) {
                    return results;
                }
            }

            return getOfferFileList(dctx, context);


        } catch(Exception e) {
            e.printStackTrace();
            return ServiceUtil.returnError("upload offer file error : " + e.getMessage());
        }
    }

    public static Map<String, Object> getOfferFileList(DispatchContext dctx, Map<String, ? extends Object> context) {
        try {
            EntityCondition cond = EntityCondition.makeCondition(
                       UtilMisc.toList(
                               EntityCondition.makeCondition("productOfferId", EntityComparisonOperator.EQUALS, context.get("offerId")),
                               EntityCondition.makeCondition("productContentTypeId", EntityComparisonOperator.EQUALS, "MISC_FILE")
                               ),
                       EntityJoinOperator.AND
                    );

            List<GenericValue> productOfferFiles = dctx.getDelegator().findList("ProductOfferContentAndInfo", cond, UtilMisc.toSet("drDataResourceName", "contentId", "fromDate", "productContentTypeId", "drObjectInfo"), null, null, false);
            List<Map<String, Object>> fileList = new ArrayList<Map<String,Object>>();
            for(GenericValue file : productOfferFiles) {
                Timestamp fromDate = file.getTimestamp("fromDate");
                Map<String, Object> entry = UtilMisc.toMap(
                        "fromDate", fromDate.getTime(),
                        "path", file.getString("drObjectInfo"),
                        "fileName", file.getString("drDataResourceName"),
                        "contentId", file.getString("contentId"),
                        "productContentTypeId", file.getString("productContentTypeId")
                        );
                fileList.add(entry);
            }
            Map<String, Object> results = ServiceUtil.returnSuccess();
            results.put("fileList", fileList);
            return results;
        } catch(Exception e) {
            e.printStackTrace();
            return ServiceUtil.returnError("upload offer file error : " + e.getMessage());
        }
    }

    public static Map<String, Object> getOfferCustomers(DispatchContext dctx, Map<String, ? extends Object> context) {
        Map<String, Object> results = ServiceUtil.returnSuccess();

        try {

            // on cherche les ligne de commande client avec cette offre
            DynamicViewEntity dynamicView = new DynamicViewEntity();
            dynamicView.addMemberEntity("OH", "OrderHeader");
            dynamicView.addAlias("OH", "orders", "orderId", null, null, null, "count-distinct");
            dynamicView.addAlias("OH", "orderTypeId", null, null, null, null, null);


            dynamicView.addMemberEntity("OI", "OrderItem");
            dynamicView.addAlias("OI", "productOfferId", null, null, null, null, null);
            dynamicView.addAlias("OI", "quantity", null, null, null, null, "sum");
            dynamicView.addViewLink("OH", "OI", Boolean.FALSE, ModelKeyMap.makeKeyMapList("orderId"));

            dynamicView.addMemberEntity("ORL", "OrderRole");
            dynamicView.addAlias("ORL", "partyId", null, null, null, null, null);
            dynamicView.addAlias("ORL", "roleTypeId", null, null, null, null, null);
            dynamicView.addViewLink("OH", "ORL", Boolean.FALSE, ModelKeyMap.makeKeyMapList("orderId"));

            dynamicView.addMemberEntity("P", "Person");
            dynamicView.addAlias("P", "firstName", null, null, null, null, null);
            dynamicView.addAlias("P", "lastName", null, null, null, null, null);
            dynamicView.addAlias("P", "personalTitle", null, null, null, null, null);
            dynamicView.addViewLink("ORL", "P", Boolean.FALSE, ModelKeyMap.makeKeyMapList("partyId"));

            dynamicView.setGroupBy(UtilMisc.toList("partyId", "firstName", "lastName", "personalTitle"));


            EntityCondition whereCondition = EntityCondition.makeCondition(
                    UtilMisc.toList(
                            EntityCondition.makeCondition("productOfferId", EntityComparisonOperator.EQUALS, context.get("offerId")),
                            EntityCondition.makeCondition("orderTypeId", EntityComparisonOperator.EQUALS, "SALES_ORDER"),
                            EntityCondition.makeCondition("roleTypeId", EntityComparisonOperator.EQUALS, "BILL_TO_CUSTOMER")
                    ),
                    EntityJoinOperator.AND
            );

            EntityListIterator orderIterator = dctx.getDelegator().findListIteratorByCondition(
                    dynamicView,
                    whereCondition,
                    null,
                    UtilMisc.toList("orders", "quantity", "partyId", "personalTitle", "lastName", "firstName"),
                    UtilMisc.toList("partyId"), new EntityFindOptions());
/*
 pour tester le résultat facilement via le SqlProcessor
select count(OH.order_Id), sum(quantity), ORL.party_Id, last_Name, first_Name
from Order_Header OH
   join Order_Item OI on (OH.order_Id = OI.order_ID)
   join Order_Role ORL on (OH.order_Id = ORL.order_ID)
   join Person P on (ORL.party_Id = P.party_Id)
where product_Offer_Id='OB10800'
   and order_Type_Id='SALES_ORDER'
   and role_Type_Id='BILL_TO_CUSTOMER'
group by ORL.party_Id, last_Name, first_Name
order by ORL.party_Id
*/

            List<Map<String, Object>> customers = new LinkedList<>();

            GenericValue order = null;
            while ((order = orderIterator.next()) != null) {
                String partyId = order.getString("partyId");
                GenericValue img = EntityUtil.getFirst(dctx.getDelegator().findByAnd(
                        "PartyContentAndInfo",
                        UtilMisc.toMap(
                                "partyId", partyId,
                                "partyContentTypeId", "LGOIMGURL"),
                        null,
                        false
                ));

                String image64 = null;

                if (UtilValidate.isNotEmpty(img)) {
                    Map<String, Object>imageContext = new HashMap<String, Object>();
                    imageContext.putAll(context);
                    imageContext.put("delegator", dctx.getDelegator());
                    imageContext.put("tenantId", dctx.getDelegator().getDelegatorTenantId());
                    String imageServerPath = FlexibleStringExpander.expandString(EntityUtilProperties.getPropertyValue("catalog", "image.server.path", dctx.getDelegator()), imageContext);

                    String targetDirectory = imageServerPath + "/customers/" + partyId;

                    image64 = new String(Base64.base64Encode(FileUtils.readFileToByteArray(new File(targetDirectory, "profile.png"))), "UTF-8");
                }

                customers.add(UtilMisc.toMap(
                        "id", partyId,
                        "title", order.getString("personalTitle"),
                        "lastName", order.getString("lastName"),
                        "firstName", order.getString("firstName"),
                        "image", image64,
                        "quantity", order.getBigDecimal("quantity").toString(),
                        "orders", order.get("orders").toString()
                ));

            }

            results.put("customers", customers);


        } catch(Exception e) {
            results = ServiceUtil.returnError("get offer customers error : " + e.getMessage());
        }
        return results;
    }
}
